:PROPERTIES:
:ID:       56453D11-4337-45DC-BB1E-DB70D72626BD
:END:
#+SETUPFILE:./hugo_setup.org
#+HUGO_SLUG: linker_essay
#+TITLE: linker essay

Tags: [[id:EE39A1B4-2E49-4BB2-A83C-77D755977FE1][linkers]]
- https://lwn.net/Articles/276782/
* Intro
** What does a linker do?
   - Converts object files into executables and shared libraries
     - C/C++/Fortran (java uses a loader)
* What's a linker: Dynamic linking, linker data types, linker operation
** Shared libs
   - shared libs were invented as an op for virtual memory systems running many processes simultaneously
     - virtual memory system would map the same routine for each process
     - first implementation in SVR3, based on COFF
       - assigned each shared library a fixed portion of virtual address space
     - SunOS4 introduced a more fleixbile version
       - programs would link shared librarys during runtime (/dynamic linker/)
       - /program linker/ are the linkers during compilation
** Basic Linker Data Types
   - Linkers use /symbols/, /relocations/, and /contents/
*** Symbols
    - Name and a value
    - usually represent static objects in the original source code
      - For C, a single symbol for each function and each global and static variable
    - used to indicate a reference to a name defined in another file
*** Relocation
    - Computation to perform on the contents
    - Usually refers to a symbol and a offset
    - Also provides an additional operand called /addend/
    - Simple relocation is "set this location in the contents to the value of this symbol + addend"
*** Contents
    - What memory should look like during the execution of the program
    - Have a size, array of bytes, and a type
    - Contain machine code generated by the compiler and assembler (/text/)
    - Also contain values of initialized variables (/data/)
    - Also contain static unnamed data like string constants or switch varialbes (/rdata/)
    - Empty uninitalized variables as well

*** Basic Linker Operation
    Linkers:
    1. Read input object files, determine the length and types of contents, reads the symbols.
    2. Build a symbol table containing all the symbols, linking undefined symbols to their definitions.
    3. Decide where the contents should go in the output executable file, which means deciding where they should go in memory when the program runs
    4. Reads the contents data and the relocations, apply the relocations to the contents, write the result to the output file
    5. Optionally write out the complete symbol table with the final value of the symbols
